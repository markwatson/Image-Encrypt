#include <iostream>
#include <iomanip>

#include "accessjpeg.h"

// constructor
accessJpeg::accessJpeg()
{
	singleblock = new char [BLOCK_SIZE];
}

// destructor
accessJpeg::~accessJpeg()
{
	// free the memory
	delete[] memblock;
	delete[] singleblock;
}

// setfile also reads the file into memory.
bool accessJpeg::readInFile(char* in)
{
	using std::ios;
	std::fstream in_file(in, ios::in|ios::binary|ios::ate);
	if (in_file.is_open())
	{
		size = in_file.tellg();
		memblock = new char [size];
		in_file.seekg(0, ios::beg);
		in_file.read(memblock, size);
		in_file.close();

		// initialize ptr.
		cursor = 0;
		// start at beginning of jpeg pixel data
		jumpToStart();
		 
	} else return false;

	return true;
}

bool accessJpeg::writeOutFile(char* out)
{
	using std::ios;
	std::ofstream out_file(out, ios::out|ios::binary);
	if (out_file.is_open())
	{
		out_file.write(memblock, size);
		out_file.close();
	} else return false;

	return true;
}

// jumps to start of actual image data
// no need to encrypt the headers of the image and such...
// returns false if not a valid jpeg.
bool accessJpeg::jumpToStart()
{
	for (int cnt=0;cnt < size;cnt++)
	{
		// 0xFFDA = start of image data
		if ((unsigned char) memblock[cnt] == 0xFF &&
			(unsigned char) memblock[cnt+1] == 0xDA)
		{
			cursor = cnt+2;
			return true;
		}
	}

	return false;
}

// access a block from the memory
char * accessJpeg::accessBlock()
{
	for(int cnt = 0;cnt < BLOCK_SIZE;cnt++)
	{
		singleblock[cnt] = memblock[cursor + cnt];
		cursor++;
	}

	return singleblock;
}

bool accessJpeg::saveBlockBack()
{
	// go back to beginning of the last block
	cursor = cursor - BLOCK_SIZE;
	// copy data back in
	for(int cnt = 0;cnt < BLOCK_SIZE;cnt++)
	{
		memblock[cursor + cnt] = singleblock[cnt];
		cursor++;
	}
}
